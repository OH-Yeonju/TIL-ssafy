#### 큐의 특성

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
  
  - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조

- 선입선출구조

- 주요 연산
  
  - enQueue(item) : 원소 삽입
  
  - deQueue() : 원소 반환, 삭제
  
  - createQueue() : 큐 생성



**선형큐**

- 1차원 배열을 이용한 큐
  
  - front : 



- 삽입 : 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
  
  1. rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련
  
  2. 그 인덱스에 해당하는 배열원소 Q[rear]에 item을 저장

- 삭제 : 가장 앞에 있는 원소를 삭제하기 위해
  
  1. front 값을 하나 증가시켜 큐에 남아있게 될 첫번째 원소 이동
  
  2. 새로운 첫번쨰 원소를 리턴함으로써 삭제와 동일한 기능

- 공백상태 및 포화상태 검사 : isEmpty(), isFull()
  
  - 공백상태 : front == rear
  
  - 포화상태 : rear == n-1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)

- 검색 : Qpeek()
  
  - 가장 앞에 있는 원소를 검색하여 반환하는 연산



**선형 큐 이용시의 문제점**

- 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고 rear=n-1인 상태, 즉 포화상태로 인식하여 더이상의 삽입을 수행하지 않게 됨
  
  - 해결방법
    
    1. 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동시킴 > 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐
    
    2. 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용



**원형 큐**

- 초기 공백 상태
  
  front = rear = 0

- Index의 순환
  
  -  ..

- front 변수
  
  공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠



##### 우선순위 큐

- 우선순위를 가진 항목들을 저장하는 큐

- FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다


