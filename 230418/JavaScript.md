##### JavaScript

- 클라이언트 측 웹브라우저에서 실행

- 웹페이지 이벤트 발생 시 어떻게 작동하는지 디자인/프로그래밍, 웹 페이지 동작을 제어하는데 널리 사용됨
  
  - 참) 장고 > 클라이언트의 요청에 맞는 응답 제공
    
    자바스크립트 > 웹페이지쪽을 좀 더 풍성하게....

- Web기술의 기반이 되는 언어
  
  HTML문서의 콘텐츠를 동적으로 변경할 수 있는 언어

###### JavaScripy Engine

- 자바스크립트 코드를 실행하는 프로그램 또는 인터프리터

- 대체적으로 웹브라우저에서 사용
  
  웹 브라우저 외 : Node.js (환경)

- 웹브라우저의 역할
  
  1. URL을 통해 web(WWW)을 탐색함
  
  2. HTML/CSS/JavaScript를 이해한 뒤 해석해서 사용자에게 하나의 화면으로 보여줌
  
  3. 웹 서비스 이용 시 클라이언트의 역할을 함
  
  \> 웹 페이지 코드를 이해하고 보여주는 역할을 하는 것이 웹 브라우저

- 각 브라우저마다 자체 자바스크립트 엔진을 개발, 사용하고 있음
  
  예) V8-chrome

- 자바스크립트 코드작성시 body닫는 태그 바로 위에 작성

**Ecma Script**

- Ecma International(전자 정보 통신 시스템 표준화 기구)이 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어를 뜻함

- JavaScript를 표준화하기위해 만들어짐

- 문법, 데이터타입, 객체 모델, 함수, 연산자 등을 정의(수업엔.. ES6+)

*시작하기전에...*

- 들여쓰기는 2칸... 블럭은 if, for함수에서 {} 내부를 의미

- 세미콜론
  
  - 자바스크립트는 세미콜론을 선택적으로 사용가능..
  
  - 없으면 ASI에 의해 자동으로 세미콜론 삽입됨

##### 변수와 식별자

- 식별자 : 변수를 구분할 수 있는 변수명

- 식별자는 반드시 문자, 달러($), 또는 밑줄(_)fh tlwkr

- 대소문자 구분하며 클래스명 외에는 모두 소문자로 시작

- 예약어(for, if, functions등) 사용 불가능

- 식별자 정의와 특징
  
  - 카멜 케이스
    
    : 변수, 객체, 함수에 사용
  
  - 파스칼 케이스
    
    : 클래스, 생성자에 사용
  
  - 대문자 스네이크 케이스
    
    : 상수(개발자의 의도와 상관없이 변경될 가능성이 없는 값)에 사용

- 변수 선언 키워드
  
  1. let
     
     블록 스코프 지역 변수를 선언(추가로 동시에 값을 초기화)
     
     재할당 가능, 재선언 불가능
  
  2. const
     
     블록 스코프 읽기 전용 상수를 선언(추가로 동시에 값을 초기화)
     
     재할당 불가능, 재선언 불가능
     
     선언 시 반드시 초기값을 설정해야 함
  
  3. var
     
     변수를 선언(추가로 동시에 값을 초기화)
     
     재할당 가능, 재선언 가능
     
     "호이스팅"되는 특성으로 예기치 못한 문제 발생 가능
     
     \> ES6이후부터는 var대신 const와 let을 사용하는 것을 권장

*[참고] 선언, 할당, 초기화*

- 선언 : 변수를 생성하는 행위 또는 시점

- 할당 : 선언된 변수에 값을 저장하는 행위 또는 시점

- 초기화 : 선언된 변수에 처음으로 값을 저장하는 행위 또는 시점

*[참고] 블록 스코프*

- if, for, 함수 등의 중괄호 {}soqnfmf rkflzla

- 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능

*[참고] 호이스팅*

- 변수를 선언 이전에 참조할 수 있는 현상

- var로 선언된 변수는 선언 이전에 참조할 수 있으며 이러한 현상을 호이스팅이라고 함

- 변수 선언 이전의 위치에서 접근 시 undefined를 반환 > 이러한 이유 때문에 var로 선언된 변수는 선언 시에 undefined로 값이 초기화되는 과정이 동시에 일어남

- le, const는 호이스팅이 일어나면 에러 발생

##### 데이터 타입

- 원시 타입(Primitive type)과 참조 타입(Reference type)으로 분류됨

- 원시 타입
  
  **Number** : 정수 또는 실수형 숫자를 표현하는 자료형
  
  \> NaN을 반환하는 경우
  
  1. 숫자로서 읽을 수 없음
  
  2. 결과가 허수인 수학 계산식
  
  3. 피연산자가 NaN
  
  4. 정의할 수 없는 계산식
  
  5. 문자열을 포함하면서 덧셈이 아닌 계산식
  
  **String** : 문자열을 표현하는 자료형
  
  - 작은 따옴표 또는 큰 따옴표 모두 가능
  
  - 곱셈, 나눗셈, 뺄셈은 안되지만 덧셈을 통해 문자열끼리 붙일 수 있음
  
  - 따옴표를 사용하면 선언시 줄 바꿈 불가능(줄바꿈시 \n사용)
  
  - Template Literal을 사용하면 줄 바꿈이 가능, 문자열 사이에 변수도 사용 가능
  
  - Template literal(템플릿 리터럴)
    
    내장된 표현식을 허용하는 문자열 작성 방식
    
    Backtick(\`` )을 이용하며 여러 줄에 걸쳐 문자열을 정의할 수도 있고 변수를 문자열 안에 바로 연결할 수 있는 이점이 생김
    
    표현식을 넣을 수 있는데 이는 \$와 중괄호(${})로 표기
  
  **null** : null 값을 나타내는 특별한 키워드
  
  - 변수의 값이 없음을 의도적으로 표현할 때 사용
  
  **undefined** : 값이 정의되어 있지 않음을 표현하는 값
  
  - 변수 선언 이후 직접 값을 할당하지 않으면 자동으로 할당됨
  
  *[참고] null과 undifined*

- null과 undifined의 가장 대표적인 차이점은 typeof연산자를 통해 타입을 확인했을 때 나타남

- null이 원시 타입임에도 불구하고 object로 출력되는 이유는 설계당시 버그 해결못한것..
  
  **Boolean** : true와 false

- 참과 거짓을 표현하는 값

- 조건문 또는 반복문에서 유용하게 사용
  
  - 조건문 또는 반복문에서 boolean이 아닌 데이터 타입은 자동 형변환 규칙에 따라 True 또는 False로 변환됨
  
  **Symbol**

- 참조 타입
  
  1. Object : 이름과 값을 가진 속성(property)들의 집합으로 이루어진 자료구조(파이썬에서 딕셔너리처럼)
     
     - 중괄호 내부에 key와 value의 쌍으로 표현
     
     - key
       
       문자열 타입만 가능
       
       key이름에 띄어쓰기 등의 구번자가 있으면 따옴표로 묶어서 표현
     
     - value
       
       모든 타입(함수 포함)가능
     
     - 객체 요소 접근
       
       - 점(.) 또는 대괄호([])로 가능
       
       - key이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능
  
  2. Array : 여러 개의 값을 순서대로 저장하는 자료구조(파이썬 리스트처럼..)
     
     - 키와 속성들을 담고 있는 참조 타입의 객체
     
     - 순서를 보장하는 특징
     
     - 주로 대괄호를 이용하여 생성하고 0을 포함한 양의 정수 인덱스로 특정 값에 접근 가능
     
     - 배열의 길이는 array.length형태로 접근 가능
       
       (참고)  배열의 마지막 원소는 array.length - 1 로 접근
  
  3. function : function키워드를 통해 생성하며 호출 시 실행될 코드를 정의
     
     - JavaScript에서 함수를 정의하는 방법은 주로 2가지로 구분됨
       
       1. 함수 선언식
          
          ```javascript
          function 함수명(매개변수) {
              //do something
          }
          ```
       
       2. 함수 표현식
          
          : 함수 표현식은 함수의 이름을 생략한 익명 함수로 접근 가능
          
          ```javascript
          변수키워드 함수명 = function(매개변수) {
              //do something
          }
          ```



##### 연산자

- 할당 연산자
  
  - 다양한 연산에 대한 단축 연산자 지원
  
  - ++ : 피연산자의 값을 1증가시키는 연산자
  
  - -- : 1감소시키는 연산자
  
  - +=, -=와 같이 더 분명한 표현으로 적을 것을 권장

- 비교 연산자
  
  - 피연산자들(숫자, 문자, boolean등)을 비교하고 결과값을 boolean으로 반환하는 연ㅅ나자
  
  - 문자열은 유니코드 값을 사용하며 표준 사전 순서를 기반으로 비교
    
    - 알파벳 순서상 후순위가 더 크다
    
    - 소문자가 대문자보다 더 크다

- 동등 연산자(==)
  
  - 두 피연산자가 같은 값으로 평가되는지 비교 후 boolean값을 반환
  
  - 비교할 때 암묵적 타입 변환 통해 타입을 일치시킨 후 같은 값인지 비교
  
  - 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별
  
  - 예상치 못한 결과가 발생할 수 있으므로 특별한 경우를 제외하고 사용하지 않음

- 일치 연산자(===)
  
  - 두 피연산자의 값과 타입이 모두 같은 경우 true를 반환
  
  - 같은 객체를 가리키거나 같은 타입이면서 같은 값인지를 비교
  
  - 엄격한 비교가 이뤄지며 암묵적 타입 변환이 발생하지 않음
    
    \> 두 비교 대상의 타입과 값 모두 같은지 비교하는 방식

- 논리 연산자
  
  - 세가지 논리 연산자로 구성
    
    - and 연산은 &&
    
    - or 연산은 ||
    
    - not 연산은 !
  
  - 단축 평가 지원
    
    예) false && true > false
    
    true||false > true

- 삼항 연산자
  
  - 3개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자
  
  - 가장 앞의 조건식이 참이면 :(콜론) 앞의 값이 반환되며 그 반대의경우 :뒤의 값이 반환되는 연산자(맞으면 앞에거 틀리면 뒤에거)

- 스프레드 연산자
  
  - 배열이나 객체를 전개하여 각 요소를 개별적인 값으로 분리하는 연산자
  
  - 주로 함수 호출 시 매개변수로 배열이나 객체를 전달할 때 사용
  
  - 앝은 복사를 위해서도 활용 가능





##### 조건문

- if, else if, else
  
  - 조건은 소괄호 안에 작성
  
  - 실행할 코드는 중괄호 안에 작성
  
  - 블록 스코프 생성





##### 반복문

- while
  
  - 조건문이 참이기만 하면 문장을 계속해서 수행

- for
  
  - 특정한 조건이 거짓을 판별될 때까지 반복
    
    ```javascript
    for ([초기문];[조건문];[증감문]) {
        //do something
    }
    ```

- for... in
  
  - 객체의 속성을 순회할 때 사용
  
  - 배열도 순회 가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장하지 않음
    
    ```javascript
    for (variable in object) {
        statements
    }
    ```

- for... of
  
  - 반복 가능한 객체(Array, Set, String)를 순회할 때 사용
    
    ```javascript
    for (variable of object) {
        statements
    }
    ```
  
  *for in 과 for of의 차이*
  
  - for in은 속성 이름을 통해 반복
  
  - for of는 속성 값을 통해 반복

- Array.forEach
  
  - 배열의 메서드들 중 하나



*[참고] for..in for..of와 const*

- for문
  
  for loop의 경우에는 최초 정의한 i를 재할당하면서 사용하기 때문에 const를 사용하면 에러 발생

- for in, for of
  
  재할당이 아니라 매 반복시 해당 변수를 새로 정의하여 사용하므로 에러가 발생하지 않음
